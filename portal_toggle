#!/usr/bin/python

"""
This isnt really a nagios plugin, but since it calls one, I re-use some code
and put it hear for convenience.

The actual switchover depends on an external binary - '~/bin/activate-environ
if that is not found, nothing bad happens, only scaling up of the passive side
"""

import time

from naglib.nagiosplugin import NagiosPlugin, NAG_WARNING, NAG_CRITICAL, NAG_OK



TASK_LIST = 'list'
TASK_TOGGLE = 'toggle'
VERBS = (TASK_LIST, TASK_TOGGLE)



class PortalToggler(NagiosPlugin):
    VERSION = '2.0.1'
    DESCRIPTION = "lists/toggles production portal"
    MSG_LABEL = 'PORTAL_TOGGLER'
    CMD_LINE_HINT = 'list / toggle'
    HELP = """
    list          show what app is currently handling production
    toggle        switches to other app after first
                   * ensuring its running
                   * ensuring the correct number of instances are running
                   * all apps are responsive
                  after switch
                   * restarts retired group
                   * scales all retired apps down to 1 instance

    """
    APP_WEB = 'web'
    APP_API = 'api'
    APP_PORTAL = 'portal'
    APP_BOTTER = 'botter'
    APPS = (APP_BOTTER, APP_PORTAL, APP_API, APP_WEB)
    INSTANCES = {APP_BOTTER:6, APP_PORTAL:3, APP_API:4, APP_WEB:3}
    GROUPS = ('blue', 'green')


    def custom_options(self, parser):
        parser.add_option("-C", '--command', dest='command', default='cf')
        parser.add_option('-P', '--prefix', dest='plugin_prefix', default='/usr/local/nagiosplugins')


    def workload(self):
        if len(self.args) != 1:
            self.exit_crit('exactly one task must be suplied as param')
        task = self.args.pop()
        if task not in VERBS:
            self.exit_crit('invalid task: %s' % task)

        initially_active, passive = self.task_list() # check what stack is currently active
        msg = 'Currently %s is active' % initially_active
        if task == TASK_LIST:
            self.exit_ok(msg)
        self.log(msg, 1)
        #
        # Activate the incoming group
        #
        self.activate_stack(group=passive, startup=True)
        #
        # Do the actual switchover
        #
        self.log('will now toggle production to %s' % passive, 1)
        cmd = '~/bin/activate-environ %s' % passive
        stdout = self.cmd_execute_abort_on_error(cmd)
        #
        # Retire the inactive group
        #
        self.activate_stack(group=initially_active, startup=False)

        self.exit_ok('portal toggled sccessfully, %s is now active' % passive)



    def task_list(self):
        # check what stack is currently active
        cmd = '%s routes' % self.options.command
        self.log('Checking routes', 1)
        stdout = self.cmd_execute_abort_on_error(cmd)
        for line in stdout.split('\n'):
            if line.find('www') > -1 and line.find('europeana.eu') > -1:
                active = line.split()[-1].split('-')[0]
                break

        if active not in self.GROUPS:
            self.exit_crit('active group (%s) not recognized' % active)

        if active == 'blue':
            passive = 'green'
        else:
            passive = 'blue'
        return active, passive


    def activate_stack(self, group, startup=True):
        """For startup True, all apps are scaled to production level
        and then the app is started if not allready running
        For startup=False all apps are scaled to 1 and restarted
        Finally we wait for all apps to be ready and operational before
        returning, upon successfull return, groups can be toggled.
        """
        if startup:
            msg = 'Preparing'
        else:
            msg = 'Retiring'
        self.log('%s stack %s' % (msg, group), 1)

        for app in self.APPS:
            app_name = '%s-%s' % (group, app)
            if startup:
                self.log('\tensuring %s is running' % app_name, 2)
                self.scale_app(app_name, self.INSTANCES[app])
                if not self.app_is_running(app_name):
                    self.log('\t  starting it', 2)
                    cmd = '%s start %s' % (self.options.command, app_name)
                    stdout = self.cmd_execute_abort_on_error(cmd)
            else:
                self.log('\tre-starting %s' % app_name, 2)
                self.scale_app(app_name, 1)
                cmd = '%s restart %s' % (self.options.command, app_name)
                stdout = self.cmd_execute_abort_on_error(cmd)


        if startup:
            final_status = 'active'
            self.log('  Waiting for all apps to beceome ready', 1)
            time.sleep(10) # give apps some time to start their processing
            timeout = time.time() + 300
            while True:
                all_ok = True
                for app in self.APPS:
                    app_name = '%s-%s' % (group, app)
                    self.log('\tchecking %s' % app_name, 2)
                    cmd = '%s/check_cf_app %s -I %i' % (self.options.plugin_prefix, app_name, self.INSTANCES[app])
                    try:
                        b = self.cmd_execute_raise_on_error(cmd)
                    except:
                        all_ok = False
                        break
                if all_ok:
                    break
                if time.time() > timeout:
                    self.exit_crit('Timeout waiting for one of the apps to come online')
                time.sleep(10)
                self.log('    Waiting max %is before timeout' % int(timeout - time.time()), 1)
        else:
            final_status = 'suspended'
        self.log('  %s is now %s' % (group, final_status), 1)
        return


    def scale_app(self, app_name, count):
        cmd = '%s scale -i %i %s' % (self.options.command, count, app_name)
        stdout = self.cmd_execute_abort_on_error(cmd)


    def app_is_running(self, app_name):
        cmd = '%s app %s' % (self.options.command, app_name)
        stdout = self.cmd_execute_abort_on_error(cmd)
        if stdout.find('requested state: started') > -1:
            running = True
            msg = 'is'
        else:
            running = False
            msg = 'is not'
        self.log('\t%s is %s running' % (app_name, msg), 3)
        return running




if __name__ == "__main__":
    PortalToggler().run()