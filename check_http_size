#!/usr/bin/env python3
"""
If you cant install the nagios check_http you can use this instead...

"""

import time
import urllib.request, urllib.error, urllib.parse

from naglib.nagiosplugin import NagiosPlugin, NAG_CRITICAL, NAG_OK



class CheckHttpSize(NagiosPlugin):
    VERSION = '1.0.5'
    DESCRIPTION = "Checks that requested document size is within bounds"
    MSG_LABEL = 'DOC_SIZE'
    CMD_LINE_HINT = 'url'
    HELP = """
    At least one of -w or -c must be given, and the notation is min:max
    Any size outside this will trigger an alarm.

    If response is not recieved within timeout period, an alarm is triggered
    """

    def custom_options(self, parser):
        parser.add_option("-w", '--warning', dest="warning", help="syntax:  min:max")
        parser.add_option("-c", '--critical', dest="critical", help="syntax:  min:max")
        parser.add_option("-t", '--timeout', dest="timeout", default=10, type="int")

    def workload(self):
        size_min = size_max = 0
        size_warn = size_crit = ''
        if len(self.args) < 1:
            self.exit_help('Mandatory param missing')
        url = self.args[0]
        if not (self.options.warning or self.options.critical):
            self.exit_help('-w or -c must be given')

        if self.options.warning:
            w1, w2 = self.verify_size_span(self.options.warning,'warning')
            size_min = w1
            size_max = w2
            size_warn = w2

        if self.options.critical:
            c1, c2 = self.verify_size_span(self.options.critical,'critical')
            size_crit = c2
            if size_min:
                size_min = min(size_min, c1)
            else:
                size_min = c1
            if size_max:
                size_max = max(size_max, c2)
            else:
                size_max = c2

        doc = self.check_url(url,timeout=self.options.timeout)
        size = len(doc)

        if size_min == 0:
            size_min = '' # never use size 0 in perf data
        if size_max == 0:
            size_max = '' # never use size 0 in perf data
        self.add_perf_data('size', size, warning=size_warn, critical=size_crit) #, minimum=size_min, maximum=size_max)
        if self.options.critical:
            if size < c1 or size > c2:
                self.exit_crit('%i is out of range' % size)
        if self.options.warning:
            if size < w1 or size > w2:
                self.exit_warn('%i is out of range' % size)

        self.exit(NAG_OK, 'Acceptable doc size: %i' % size)


    def check_url(self, url, s_expect='', timeout=10):
        t1 = time.time()
        try:
            f = urllib.request.urlopen(url, timeout=timeout)
        except urllib.error.HTTPError as e:
            self.exit_crit('HTTP error:%i - %s' % (e.code,e.msg))
        except:
            if time.time() > t1 + timeout:
                self.exit_crit('timeout!')
            self.exit_crit( 'unknwon failure processing url')
        if f.code != 200:
            self.exit_crit( '%s %s' % (f.code, f.msg))
        content = f.read()
        if s_expect and (content.find(s_expect) < 0):
            self.exit_crit( '%s not found' % s_expect)
        return content


    def verify_size_span(self, param, label):
        try:
            parts = param.split(':')
        except:
            self.exit_help('bad syntax for %s - %s' % (label, param))
        if not len(parts) == 2:
            self.exit_help('there should be exactly 2 numbers given for %s - %s' % (label, param))
        m1 = parts[0]
        m2 = parts[1]
        try:
            m1 = int(m1)
        except:
            self.exit_help('value (%s) is not a number, %s - %s' % (m1, label, param))
        try:
            m2 = int(m2)
        except:
            self.exit_help('value (%s) is not a number, %s - %s' % (m2, label, param))
        if m1 >= m2:
            self.exit_help('second number must be larger than first, %s - %s' % (label, param))

        return m1, m2


if __name__ == "__main__":
    CheckHttpSize().run()

